<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Memorization Activity Tool</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<h1>Memorization Activity Tool</h1>

<h2>Study Background</h2>
<p>Many times during the term, you may feel like your brain just cannot hold all of the information you are learning in your classes. Are there ways to improve our memories so that we can comprehend even more information? Research in cognitive psychology has suggested that the answer to that question is a resounding “yes”. This literature has suggested several strategies to improve memory, enhance recall, and increase retention of information. </p> 
<p>One of the strategies identified by cognitive psychologists is that of chunking. Chunking refers to the process of taking individual units of information and grouping them into larger units (chunks). One common example of chunking occurs when we write and recall phone numbers. For example, a sequence of digits in a phone number, say 8-6-7-5-3-0-9, would be chunked into 867-5309. </p> 
<p>In this activity, our class will perform an experiment to determine if familiar chunks of letters are easier to remember than less familiar ones. Our goal is to answer the following research question:</p>
<center><strong>Is there evidence that familiar chunks are on average easier to remember?</strong></center>
<h2>Preparing the Survey</h2>
<p>In this activity, your students will be randomly assigned to one of two conditions. One condition will be asked to memorize a sequence of 30 letters, where all 30 letters are chunked by hyphens into groups of 3 letters, where all letters are familiar acronyms or initialisms:</p>
<center><strong>JFK-CIA-FBI-USA-SAT-GPA-GRE-IBM-NBA-CPR</strong></center>
<p>In the other group, they will receive the same string of 30 letters, but with the hyphens in different locations to obscure these familiar chunks:<p>
<center><strong>JFKC-IAF-BIU-SASA-TGP-AGR-EIB-MN-BAC-PR</strong></center>
<p>We can then test the effect of familiar chunking by analyzing the data we receive from this experiment. To administer this memory experiment with your students, you can use one of the two Qualtrics templates below. If you have an institutional license or a paid Qualtrics account, I suggest using the template that has timers built-in to ensure students all have the same amount of memorization time and waiting time. If you do not have access to Qualtrics through your institution and are using a free account, then use the template with no timers.</p>
  <ul>
    <li><a href="Memorization_Randomized.qsf">Qualtrics Template, with Timers</a></li>
    <li><a href="Memorization_Randomized_No_Timers.qsf">Qualtrics Template, no Timers</a></li>
  </ul>
<p>For more information about importing templates into Qualtrics, see <a href="https://www.qualtrics.com/support/survey-platform/survey-module/survey-tools/import-and-export-surveys/">this help file on the Qualtrics website.</a></p> Once you have the survey imported, you just need to click the "Publish" button, which will generate a survey link that you can share with your students. The survey is already set up to randomly assign students to either the "good chunking"/"JFK" condition, or the "bad chunking"/"JFKC" condition. If you are using the survey version that does not have timers, be sure to have your students all go through the survey together, and use a 20 second timer for the memorization page, and a 2-minute timer for the waiting page. When you have had all your students complete the survey, go to the "Data and Analysis" tab, then click "Export & Import", "Export Data...", and then "Download." You can then directly upload this CSV file to the upload below to score all your students' results. You can then distribute the exported data to them, or project the data visualization and summary statistics options within this tool to have them analyze the data.</p>

<h2>AI Acknowledgement</h2>
<p>Much of the code for this tool was created with assistance from AI. Several test cases were run to ensure accuracy of results generated by this tool, but please reach out if you find any errors or bugs. Data files remain local on your machine as this tool runs, so using this tool should not incur additional risk of a data breach.</p>
  
<h2>Uploading Qualtrics Data</h2>

<input type="file" id="fileInput" accept=".csv">
<label>
  Number of header rows: (Qualtrics default is 3)
  <input type="number" id="headerRows" value="3" min="0" style="width:60px;">
</label>

<p>If you want to try out the tool with sample data, use <a href="Memorization Example.csv">this example Qualtrics export.</a></p>
<div id="controls" style="display:none;">
  
<h2>Column selection</h2>
<label>Name column:
  <select id="nameCol"></select>
</label>

<label>Letters guessed column:
  <select id="lettersCol"></select>
</label>

<label>Condition column:
  <select id="conditionCol"></select>
</label>

<h2>Export Data to CSV</h2>

<div id="preview"></div>
  
<label>
  <input type="checkbox" id="includeName" checked>
  Include Name
</label>

<label>
  <input type="checkbox" id="includeLetters" checked>
  Include Letters guessed
</label>

<button onclick="downloadCSV()">Download Scored CSV</button>
  
<h2>Histogram</h2>
<label>
  <input type="checkbox" id="showMean">
  Show mean
</label>

<label style="margin-left:20px; display:none;" id="showSDWrapper">
  <input type="checkbox" id="showSD">
  Show SD (±1)
</label>
  
<label>
  <input type="checkbox" id="showMedian">
  Show median
</label>

<label>
  <input type="checkbox" id="showStats">
  Show summary statistics
</label>

<canvas id="histogramCanvas" width="950" height="520"></canvas>

<h2>Hypothesis Testing</h2>
  
<label>
  <input type="checkbox" id="showTTest">
  Show t-test results
</label>

<label style="margin-left:20px; display:none;" id="pooledWrapper">
  <input type="checkbox" id="usePooled">
  Use pooled SD
</label>

<div id="tTestResults" style="
  margin-top: 12px;
  padding: 10px;
  border: 1px solid #ccc;
  background: #fafafa;
  font-family: Arial, sans-serif;
  font-size: 14px;
  display: none;
">
</div>
</div>
  
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
const CORRECT = "JFKCIAFBIUSASATGPAGREIBMNBACPR";

const CONDITION_LABELS = {
  JFK: "Chunking",
  JFKC: "No chunking"
};

let rawData = [];
let processedData = [];

// ------------------ Scoring ------------------
function countCorrectFromStart(studentLetters) {
  if (!studentLetters) return 0;
  const cleaned = studentLetters
    .toUpperCase()
    .replace(/[^A-Z]/g, "");

  let count = 0;
  for (let i = 0; i < Math.min(cleaned.length, CORRECT.length); i++) {
    if (cleaned[i] === CORRECT[i]) count++;
    else break;
  }
  return count;
}

// ------------------ Parsing ------------------
document.getElementById("fileInput").addEventListener("change", function(e) {
  const file = e.target.files[0];
  if (!file) return;

  Papa.parse(file, {
    skipEmptyLines: true,
    complete: function(results) {
      const rows = results.data;

      const headerCount = parseInt(document.getElementById("headerRows").value, 10) || 0;

      const headers = rows[0];
      const dataRows = rows.slice(headerCount);

      rawData = dataRows.map(row => {
        const obj = {};
        headers.forEach((h, i) => obj[h] = row[i]);
        return obj;
      });

      processedData = rawData.map(row => {
        const name = row[nameCol] || "";
        const letters = (row[lettersCol] || "").toUpperCase().replace(/[^A-Z]/g, "");
        const condition = (row[conditionCol] || "").trim();

        return {
          name,
          letters,
          condition,
        score: countCorrectFromStart(letters)
        };
      });

      populateDropdowns(headers);
      setDefaultSelections(headers);
      updatePreview();

      document.getElementById("controls").style.display = "block";
      drawHistograms();
    }
  });
});

// ------------------ UI helpers ------------------
function populateDropdowns(headers) {
  ["nameCol", "lettersCol", "conditionCol"].forEach(id => {
    const select = document.getElementById(id);
    select.innerHTML = "";
    headers.forEach(h => {
      const option = document.createElement("option");
      option.value = h;
      option.textContent = h;
      select.appendChild(option);
    });
  });
}

function setDefaultSelections(headers) {
  const defaults = {
    nameCol: "Name",
    lettersCol: "Letters",
    conditionCol: "Group"
  };

  Object.entries(defaults).forEach(([id, val]) => {
    if (headers.includes(val)) {
      document.getElementById(id).value = val;
    }
  });
}

function buildProcessedData() {
  const nameCol = document.getElementById("nameCol").value;
  const lettersCol = document.getElementById("lettersCol").value;
  const conditionCol = document.getElementById("conditionCol").value;
  const includeName = document.getElementById("includeName").checked;
  const includeLetters = document.getElementById("includeLetters").checked;

  processedData = rawData.map(row => {
    const out = {};
    if (includeName) out.Name = row[nameCol];
    if (includeLetters) out.Letters = row[lettersCol];
    out.Condition = row[conditionCol];
    out.NumberCorrect = countCorrectFromStart(row[lettersCol]);
    return out;
  });
}

function updatePreview() {
  buildProcessedData();
  const preview = document.getElementById("preview");
  preview.innerHTML = "";

  if (!processedData.length) return;

  const table = document.createElement("table");
  const headerRow = document.createElement("tr");
  Object.keys(processedData[0]).forEach(k => {
    const th = document.createElement("th");
    th.textContent = k;
    headerRow.appendChild(th);
  });
  table.appendChild(headerRow);

  processedData.slice(0, 10).forEach(row => {
    const tr = document.createElement("tr");
    Object.values(row).forEach(v => {
      const td = document.createElement("td");
      td.textContent = v ?? "";
      tr.appendChild(td);
    });
    table.appendChild(tr);
  });

  preview.appendChild(table);
}

["nameCol","lettersCol","conditionCol","includeName","includeLetters"]
  .forEach(id => document.getElementById(id).addEventListener("change", updatePreview));

document.getElementById("showMean").addEventListener("change", e => {
  document.getElementById("showSDWrapper").style.display =
    e.target.checked ? "block" : "none";
  drawHistograms();
});

document.getElementById("showTTest").addEventListener("change", e => {
  document.getElementById("pooledWrapper").style.display =
    e.target.checked ? "block" : "none";
});
  
// ------------------ Histogram ------------------
function drawHistograms() {
  buildProcessedData();

  const canvas = document.getElementById("histogramCanvas");
  if (!canvas) {
    alert("Histogram canvas not found.");
    return;
  }
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // remove empty/undefined conditions
  processedData = processedData.filter(d => d.Condition && d.Condition.trim() !== "");

  const groups = {};
  processedData.forEach(d => {
    if (!d.Condition) return;

    const cond = d.Condition.trim().toUpperCase();
    if (cond === "") return;
 
    if (!groups[cond]) groups[cond] = [];
    groups[cond].push(d.NumberCorrect);
  });

  const conds = Object.keys(groups);
  if (Object.keys(groups).length !== 2) {
    alert(
      `Histogram requires exactly two conditions.\n\nDetected: ${Object.keys(groups).join(", ")}`
    );
    return;
  }

  const bins = Array.from({length:31},(_,i)=>i);
  const counts = conds.map(c => {
    const arr = Array(31).fill(0);
    groups[c].forEach(v => arr[v]++);
    return arr;
  });

  const maxCount = Math.max(...counts.flat());
  const pad = 60;
  const plotH = (canvas.height - pad*3)/2;
  const plotW = canvas.width - pad*2;
  const bw = plotW / bins.length;

  counts.forEach((arr, idx) => {
    const y0 = pad + idx*(plotH+pad);
    const label = CONDITION_LABELS[conds[idx]] || conds[idx];

    ctx.fillStyle = "#000";
    ctx.font = "bold 16px Arial";
    ctx.fillText(label, pad, y0 - 12);
    
    arr.forEach((c,i)=>{
      const h = (c/maxCount)*plotH;
      ctx.fillStyle="#4a90e2";
      ctx.fillRect(pad+i*bw, y0+plotH-h, bw-1, h);
    });

    const vals = groups[conds[idx]];
    const mean = vals.reduce((a,b)=>a+b,0)/vals.length;
    const med = vals.slice().sort((a,b)=>a-b)[Math.floor(vals.length/2)];
    const sd = Math.sqrt(
      vals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (vals.length - 1)
    );

    if (document.getElementById("showMean").checked) {
      drawLine(mean, y0, plotH, "solid");
    }
    if (document.getElementById("showMedian").checked) {
      drawLine(med, y0, plotH, "dashed");
    }

    if (
      document.getElementById("showMean").checked &&
      document.getElementById("showSD")?.checked
    ) {
      const xMean = pad + mean * bw;
      const yMid = y0 + plotH / 2;
      const sdPixels = sd * bw;

      ctx.strokeStyle = "#000";
      ctx.beginPath();
      ctx.moveTo(xMean - sdPixels, yMid);
      ctx.lineTo(xMean + sdPixels, yMid);
      ctx.stroke();

      // end caps
      ctx.beginPath();
      ctx.moveTo(xMean - sdPixels, yMid - 5);
      ctx.lineTo(xMean - sdPixels, yMid + 5);
      ctx.moveTo(xMean + sdPixels, yMid - 5);
      ctx.lineTo(xMean + sdPixels, yMid + 5);
      ctx.stroke();
    }
    
    // X-axis labels
    ctx.fillStyle = "#000";
    ctx.font = "12px Arial";
    for (let i = 0; i <= 30; i += 5) {
      const x = pad + i * bw;
      ctx.fillText(i.toString(), x - 4, y0 + plotH + 18);
    }
    if (document.getElementById("showStats").checked) {
      const skew = skewness(vals, mean, sd);

      const boxX = pad + plotW - 160;
      const boxY = y0 + 10;

      ctx.fillStyle = "#fff";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      ctx.fillRect(boxX, boxY, 150, 90);
      ctx.strokeRect(boxX, boxY, 150, 90);

      ctx.fillStyle = "#000";
      ctx.font = "12px Arial";
      ctx.fillText(`Mean: ${mean.toFixed(2)}`, boxX + 8, boxY + 18);
      ctx.fillText(`Median: ${med.toFixed(2)}`, boxX + 8, boxY + 34);
      ctx.fillText(`SD: ${sd.toFixed(2)}`, boxX + 8, boxY + 50);
      ctx.fillText(`Skew: ${skew.toFixed(2)}`, boxX + 8, boxY + 66);
    }
  });

  renderTTestResults(groups, conds);
  
  function drawLine(val, y0, h, style) {
    const x = pad + val * bw;

    ctx.strokeStyle = "#000";
    ctx.setLineDash(style === "dashed" ? [6, 4] : []);
    ctx.beginPath();
    ctx.moveTo(x, y0);
    ctx.lineTo(x, y0 + h);
    ctx.stroke();
    ctx.setLineDash([]);
  }
}

// ------------------ Download ------------------
function downloadCSV() {
  if (!processedData.length) return alert("Upload data first.");
  const csv = Papa.unparse(processedData);
  const blob = new Blob([csv],{type:"text/csv"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "memorization_data.csv";
  a.click();
}

[
  "nameCol",
  "lettersCol",
  "conditionCol",
  "includeName",
  "includeLetters",
  "showMean",
  "showMedian",
  "showSD",
  "showStats",
  "showTTest",
  "usePooled"
].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;

  el.addEventListener("change", () => {
    updatePreview();
    drawHistograms();
  });
});

function copyToClipboard() {
  if (!processedData.length) {
    alert("No data to copy.");
    return;
  }
  const csv = Papa.unparse(processedData);
  navigator.clipboard.writeText(csv)
    .then(() => alert("CSV copied to clipboard. Paste directly into CODAP."))
    .catch(() => alert("Clipboard copy failed."));
}

// ------------- Statistics Functions -------------

function skewness(arr, mean, sd) {
  const n = arr.length;
  return arr.reduce((a, b) => a + Math.pow((b - mean) / sd, 3), 0) * (n / ((n - 1) * (n - 2)));
}

function tCDF(t, df) {
  // Abramowitz & Stegun approximation
  const x = df / (df + t * t);
  const a = 0.5 * df;
  const b = 0.5;
  let betacf = (x, a, b) => {
    let m2, aa, c, d, del, h;
    const MAXIT = 100;
    const EPS = 3e-7;
    const FPMIN = 1e-30;

    c = 1;
    d = 1 - (a + b) * x / (a + 1);
    if (Math.abs(d) < FPMIN) d = FPMIN;
    d = 1 / d;
    h = d;

    for (let m = 1; m <= MAXIT; m++) {
      m2 = 2 * m;
      aa = m * (b - m) * x / ((a + m2 - 1) * (a + m2));
      d = 1 + aa * d;
      if (Math.abs(d) < FPMIN) d = FPMIN;
      c = 1 + aa / c;
      if (Math.abs(c) < FPMIN) c = FPMIN;
      d = 1 / d;
      h *= d * c;

      aa = -(a + m) * (a + b + m) * x / ((a + m2) * (a + m2 + 1));
      d = 1 + aa * d;
      if (Math.abs(d) < FPMIN) d = FPMIN;
      c = 1 + aa / c;
      if (Math.abs(c) < FPMIN) c = FPMIN;
      d = 1 / d;
      del = d * c;
      h *= del;

      if (Math.abs(del - 1) < EPS) break;
    }
    return h;
  };

  const bt = Math.exp(
    a * Math.log(x) +
    b * Math.log(1 - x) -
    Math.log(a) -
    Math.log(beta(a, b))
  );

  const result =
    t >= 0
      ? 1 - 0.5 * bt * betacf(x, a, b)
      : 0.5 * bt * betacf(x, a, b);

  return result;
}

function beta(a, b) {
  return Math.exp(logGamma(a) + logGamma(b) - logGamma(a + b));
}

function logGamma(z) {
  const g = 7;
  const p = [
    0.99999999999980993,
    676.5203681218851,
    -1259.1392167224028,
    771.32342877765313,
    -176.61502916214059,
    12.507343278686905,
    -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7
  ];
  if (z < 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - logGamma(1 - z);
  z -= 1;
  let x = p[0];
  for (let i = 1; i < g + 2; i++) x += p[i] / (z + i);
  const t = z + g + 0.5;
  return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x);
}

function tTest(a, b, pooled = false) {
  const mean = arr => arr.reduce((x,y)=>x+y,0)/arr.length;
  const variance = arr => {
    const m = mean(arr);
    return arr.reduce((x,y)=>x+Math.pow(y-m,2),0)/(arr.length-1);
  };

  const m1 = mean(a), m2 = mean(b);
  const v1 = variance(a), v2 = variance(b);
  const n1 = a.length, n2 = b.length;

  let se, df;

  if (pooled) {
    const sp2 = ((n1-1)*v1 + (n2-1)*v2) / (n1 + n2 - 2);
    se = Math.sqrt(sp2 * (1/n1 + 1/n2));
    df = n1 + n2 - 2;
  } else {
    se = Math.sqrt(v1/n1 + v2/n2);
    df = Math.pow(v1/n1 + v2/n2,2) /
         (Math.pow(v1/n1,2)/(n1-1) + Math.pow(v2/n2,2)/(n2-1));
  }

  const t = (m2 - m1) / se;
  const p = 2 * (1 - tCDF(Math.abs(t), df));
  const crit = Math.abs(tInv(0.975, df)); // approx
  const ci = [
    (m2 - m1) - crit * se,
    (m2 - m1) + crit * se
  ];

  return { t, df, se, p, diff: m2 - m1, ci };
}

function renderTTestResults(groups, conds) {
  const container = document.getElementById("tTestResults");

  if (!document.getElementById("showTTest").checked) {
    container.style.display = "none";
    container.innerHTML = "";
    return;
  }

  const pooled = document.getElementById("usePooled").checked;
  const res = tTest(groups[conds[0]], groups[conds[1]], pooled);

  container.style.display = "block";
  container.innerHTML = `
    <strong>Two-Sample t-Test (${pooled ? "Pooled" : "Unpooled"})</strong><br><br>
    <table style="border-collapse:collapse;">
      <tr><td style="padding-right:12px;">Difference in means</td><td>${res.diff.toFixed(3)}</td></tr>
      <tr><td>Standard error</td><td>${res.se.toFixed(3)}</td></tr>
      <tr><td>t statistic</td><td>${res.t.toFixed(3)}</td></tr>
      <tr><td>Degrees of freedom</td><td>${res.df.toFixed(2)}</td></tr>
      <tr><td>p-value (two-sided)</td><td>${res.p.toFixed(4)}</td></tr>
      <tr>
        <td>95% CI for Δμ</td>
        <td>[${res.ci[0].toFixed(3)}, ${res.ci[1].toFixed(3)}]</td>
      </tr>
    </table>
  `;
}

function tInv(p, df, tol = 1e-8) {
  if (p <= 0 || p >= 1) {
    throw new Error("p must be between 0 and 1");
  }

  // exploit symmetry
  if (p < 0.5) {
    return -tInv(1 - p, df, tol);
  }

  let low = 0;
  let high = 10;

  // expand upper bound if needed
  while (tCDF(high, df) < p) {
    high *= 2;
  }

  while (high - low > tol) {
    const mid = (low + high) / 2;
    if (tCDF(mid, df) < p) {
      low = mid;
    } else {
      high = mid;
    }
  }

  return (low + high) / 2;
}
  
</script>

</body>
</html>
