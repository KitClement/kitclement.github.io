<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Memorization Activity Data Tool</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="topnav">
  <a href="index.html">Home</a>
  <a href="activities.html">Activities and Notes</a>
  <a href="tool.html" class="active">Data Tool</a>
</div>
  
<h1>Memorization Activity Data Tool</h1>
  
<h2>Uploading Qualtrics Data</h2>

<input type="file" id="fileInput" accept=".csv">
<label>
  Number of header rows: (Qualtrics default is 3)
  <input type="number" id="headerRows" value="3" min="0" style="width:60px;">
</label>

<p>If you want to try out the tool with sample data, use <a href="Memorization Example.csv">this example Qualtrics export.</a></p>
<div id="controls" style="display:none;">
  
<h2>Column selection</h2>
<label>Name column:
  <select id="nameCol"></select>
</label>

<label>Letters guessed column:
  <select id="lettersCol"></select>
</label>

<label>Condition column:
  <select id="conditionCol"></select>
</label>

<h2>Export Data to CSV</h2>

<div id="preview"></div>
  
<label>
  <input type="checkbox" id="includeName" checked>
  Include Name
</label>

<label>
  <input type="checkbox" id="includeLetters" checked>
  Include Letters guessed
</label>

<button onclick="downloadCSV()">Download Scored CSV</button>
  
<h2>Histogram</h2>
<label>
  <input type="checkbox" id="showMean">
  Show mean
</label>

<label style="margin-left:20px; display:none;" id="showSDWrapper">
  <input type="checkbox" id="showSD">
  Show SD (±1)
</label>
  
<label>
  <input type="checkbox" id="showMedian">
  Show median
</label>

<label>
  <input type="checkbox" id="showStats">
  Show summary statistics
</label>

<canvas id="histogramCanvas" width="950" height="520"></canvas>

<h2>Hypothesis Testing</h2>
  
<label>
  <input type="checkbox" id="showTTest">
  Show t-test results
</label>

<label style="margin-left:20px; display:none;" id="pooledWrapper">
  <input type="checkbox" id="usePooled">
  Use pooled SD
</label>

<div id="tTestResults" style="
  margin-top: 12px;
  padding: 10px;
  border: 1px solid #ccc;
  background: #fafafa;
  font-family: Arial, sans-serif;
  font-size: 14px;
  display: none;
">
</div>
</div>
  
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
const CORRECT = "JFKCIAFBIUSASATGPAGREIBMNBACPR";

const CONDITION_LABELS = {
  JFK: "Chunking",
  JFKC: "No chunking"
};

let rawData = [];
let processedData = [];

// ------------------ Scoring ------------------
function countCorrectFromStart(studentLetters) {
  if (!studentLetters) return 0;
  const cleaned = studentLetters
    .toUpperCase()
    .replace(/[^A-Z]/g, "");

  let count = 0;
  for (let i = 0; i < Math.min(cleaned.length, CORRECT.length); i++) {
    if (cleaned[i] === CORRECT[i]) count++;
    else break;
  }
  return count;
}

// ------------------ Parsing ------------------
document.getElementById("fileInput").addEventListener("change", function(e) {
  const file = e.target.files[0];
  if (!file) return;

  Papa.parse(file, {
    skipEmptyLines: true,
    complete: function(results) {
      const rows = results.data;

      const headerCount = parseInt(document.getElementById("headerRows").value, 10) || 0;

      const headers = rows[0];
      const dataRows = rows.slice(headerCount);

      rawData = dataRows.map(row => {
        const obj = {};
        headers.forEach((h, i) => obj[h] = row[i]);
        return obj;
      });

      processedData = rawData.map(row => {
        const name = row[nameCol] || "";
        const letters = (row[lettersCol] || "").toUpperCase().replace(/[^A-Z]/g, "");
        const condition = (row[conditionCol] || "").trim();

        return {
          name,
          letters,
          condition,
        score: countCorrectFromStart(letters)
        };
      });

      populateDropdowns(headers);
      setDefaultSelections(headers);
      updatePreview();

      document.getElementById("controls").style.display = "block";
      drawHistograms();
    }
  });
});

// ------------------ UI helpers ------------------
function populateDropdowns(headers) {
  ["nameCol", "lettersCol", "conditionCol"].forEach(id => {
    const select = document.getElementById(id);
    select.innerHTML = "";
    headers.forEach(h => {
      const option = document.createElement("option");
      option.value = h;
      option.textContent = h;
      select.appendChild(option);
    });
  });
}

function setDefaultSelections(headers) {
  const defaults = {
    nameCol: "Name",
    lettersCol: "Letters",
    conditionCol: "Group"
  };

  Object.entries(defaults).forEach(([id, val]) => {
    if (headers.includes(val)) {
      document.getElementById(id).value = val;
    }
  });
}

function buildProcessedData() {
  const nameCol = document.getElementById("nameCol").value;
  const lettersCol = document.getElementById("lettersCol").value;
  const conditionCol = document.getElementById("conditionCol").value;
  const includeName = document.getElementById("includeName").checked;
  const includeLetters = document.getElementById("includeLetters").checked;

  processedData = rawData.map(row => {
    const out = {};
    if (includeName) out.Name = row[nameCol];
    if (includeLetters) out.Letters = row[lettersCol];
    out.Condition = row[conditionCol];
    out.NumberCorrect = countCorrectFromStart(row[lettersCol]);
    return out;
  });
}

function updatePreview() {
  buildProcessedData();
  const preview = document.getElementById("preview");
  preview.innerHTML = "";

  if (!processedData.length) return;

  const table = document.createElement("table");
  const headerRow = document.createElement("tr");
  Object.keys(processedData[0]).forEach(k => {
    const th = document.createElement("th");
    th.textContent = k;
    headerRow.appendChild(th);
  });
  table.appendChild(headerRow);

  processedData.slice(0, 10).forEach(row => {
    const tr = document.createElement("tr");
    Object.values(row).forEach(v => {
      const td = document.createElement("td");
      td.textContent = v ?? "";
      tr.appendChild(td);
    });
    table.appendChild(tr);
  });

  preview.appendChild(table);
}

["nameCol","lettersCol","conditionCol","includeName","includeLetters"]
  .forEach(id => document.getElementById(id).addEventListener("change", updatePreview));

document.getElementById("showMean").addEventListener("change", e => {
  document.getElementById("showSDWrapper").style.display =
    e.target.checked ? "block" : "none";
  drawHistograms();
});

document.getElementById("showTTest").addEventListener("change", e => {
  document.getElementById("pooledWrapper").style.display =
    e.target.checked ? "block" : "none";
});
  
// ------------------ Histogram ------------------
function drawHistograms() {
  buildProcessedData();

  const canvas = document.getElementById("histogramCanvas");
  if (!canvas) {
    alert("Histogram canvas not found.");
    return;
  }
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // remove empty/undefined conditions
  processedData = processedData.filter(d => d.Condition && d.Condition.trim() !== "");

  const groups = {};
  processedData.forEach(d => {
    if (!d.Condition) return;

    const cond = d.Condition.trim().toUpperCase();
    if (cond === "") return;
 
    if (!groups[cond]) groups[cond] = [];
    groups[cond].push(d.NumberCorrect);
  });

  const conds = Object.keys(groups);
  if (Object.keys(groups).length !== 2) {
    alert(
      `Histogram requires exactly two conditions.\n\nDetected: ${Object.keys(groups).join(", ")}`
    );
    return;
  }

  const bins = Array.from({length:31},(_,i)=>i);
  const counts = conds.map(c => {
    const arr = Array(31).fill(0);
    groups[c].forEach(v => arr[v]++);
    return arr;
  });

  const maxCount = Math.max(...counts.flat());
  const pad = 60;
  const plotH = (canvas.height - pad*3)/2;
  const plotW = canvas.width - pad*2;
  const bw = plotW / bins.length;

  counts.forEach((arr, idx) => {
    const y0 = pad + idx*(plotH+pad);
    const label = CONDITION_LABELS[conds[idx]] || conds[idx];

    ctx.fillStyle = "#000";
    ctx.font = "bold 16px Arial";
    ctx.fillText(label, pad, y0 - 12);
    
    arr.forEach((c,i)=>{
      const h = (c/maxCount)*plotH;
      ctx.fillStyle="#4a90e2";
      ctx.fillRect(pad+i*bw, y0+plotH-h, bw-1, h);
    });

    const vals = groups[conds[idx]];
    const mean = vals.reduce((a,b)=>a+b,0)/vals.length;
    const med = vals.slice().sort((a,b)=>a-b)[Math.floor(vals.length/2)];
    const sd = Math.sqrt(
      vals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (vals.length - 1)
    );

    if (document.getElementById("showMean").checked) {
      drawLine(mean, y0, plotH, "solid");
    }
    if (document.getElementById("showMedian").checked) {
      drawLine(med, y0, plotH, "dashed");
    }

    if (
      document.getElementById("showMean").checked &&
      document.getElementById("showSD")?.checked
    ) {
      const xMean = pad + mean * bw;
      const yMid = y0 + plotH / 2;
      const sdPixels = sd * bw;

      ctx.strokeStyle = "#000";
      ctx.beginPath();
      ctx.moveTo(xMean - sdPixels, yMid);
      ctx.lineTo(xMean + sdPixels, yMid);
      ctx.stroke();

      // end caps
      ctx.beginPath();
      ctx.moveTo(xMean - sdPixels, yMid - 5);
      ctx.lineTo(xMean - sdPixels, yMid + 5);
      ctx.moveTo(xMean + sdPixels, yMid - 5);
      ctx.lineTo(xMean + sdPixels, yMid + 5);
      ctx.stroke();
    }
    
    // X-axis labels
    ctx.fillStyle = "#000";
    ctx.font = "12px Arial";
    for (let i = 0; i <= 30; i += 5) {
      const x = pad + i * bw;
      ctx.fillText(i.toString(), x - 4, y0 + plotH + 18);
    }
    if (document.getElementById("showStats").checked) {
      const skew = skewness(vals, mean, sd);

      const boxX = pad + plotW - 160;
      const boxY = y0 + 10;

      ctx.fillStyle = "#fff";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      ctx.fillRect(boxX, boxY, 150, 90);
      ctx.strokeRect(boxX, boxY, 150, 90);

      ctx.fillStyle = "#000";
      ctx.font = "12px Arial";
      ctx.fillText(`Mean: ${mean.toFixed(2)}`, boxX + 8, boxY + 18);
      ctx.fillText(`Median: ${med.toFixed(2)}`, boxX + 8, boxY + 34);
      ctx.fillText(`SD: ${sd.toFixed(2)}`, boxX + 8, boxY + 50);
      ctx.fillText(`Skew: ${skew.toFixed(2)}`, boxX + 8, boxY + 66);
    }
  });

  renderTTestResults(groups, conds);
  
  function drawLine(val, y0, h, style) {
    const x = pad + val * bw;

    ctx.strokeStyle = "#000";
    ctx.setLineDash(style === "dashed" ? [6, 4] : []);
    ctx.beginPath();
    ctx.moveTo(x, y0);
    ctx.lineTo(x, y0 + h);
    ctx.stroke();
    ctx.setLineDash([]);
  }
}

// ------------------ Download ------------------
function downloadCSV() {
  if (!processedData.length) return alert("Upload data first.");
  const csv = Papa.unparse(processedData);
  const blob = new Blob([csv],{type:"text/csv"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "memorization_data.csv";
  a.click();
}

[
  "nameCol",
  "lettersCol",
  "conditionCol",
  "includeName",
  "includeLetters",
  "showMean",
  "showMedian",
  "showSD",
  "showStats",
  "showTTest",
  "usePooled"
].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;

  el.addEventListener("change", () => {
    updatePreview();
    drawHistograms();
  });
});

function copyToClipboard() {
  if (!processedData.length) {
    alert("No data to copy.");
    return;
  }
  const csv = Papa.unparse(processedData);
  navigator.clipboard.writeText(csv)
    .then(() => alert("CSV copied to clipboard. Paste directly into CODAP."))
    .catch(() => alert("Clipboard copy failed."));
}

// ------------- Statistics Functions -------------

function skewness(arr, mean, sd) {
  const n = arr.length;
  return arr.reduce((a, b) => a + Math.pow((b - mean) / sd, 3), 0) * (n / ((n - 1) * (n - 2)));
}

function tCDF(t, df) {
  // Abramowitz & Stegun approximation
  const x = df / (df + t * t);
  const a = 0.5 * df;
  const b = 0.5;
  let betacf = (x, a, b) => {
    let m2, aa, c, d, del, h;
    const MAXIT = 100;
    const EPS = 3e-7;
    const FPMIN = 1e-30;

    c = 1;
    d = 1 - (a + b) * x / (a + 1);
    if (Math.abs(d) < FPMIN) d = FPMIN;
    d = 1 / d;
    h = d;

    for (let m = 1; m <= MAXIT; m++) {
      m2 = 2 * m;
      aa = m * (b - m) * x / ((a + m2 - 1) * (a + m2));
      d = 1 + aa * d;
      if (Math.abs(d) < FPMIN) d = FPMIN;
      c = 1 + aa / c;
      if (Math.abs(c) < FPMIN) c = FPMIN;
      d = 1 / d;
      h *= d * c;

      aa = -(a + m) * (a + b + m) * x / ((a + m2) * (a + m2 + 1));
      d = 1 + aa * d;
      if (Math.abs(d) < FPMIN) d = FPMIN;
      c = 1 + aa / c;
      if (Math.abs(c) < FPMIN) c = FPMIN;
      d = 1 / d;
      del = d * c;
      h *= del;

      if (Math.abs(del - 1) < EPS) break;
    }
    return h;
  };

  const bt = Math.exp(
    a * Math.log(x) +
    b * Math.log(1 - x) -
    Math.log(a) -
    Math.log(beta(a, b))
  );

  const result =
    t >= 0
      ? 1 - 0.5 * bt * betacf(x, a, b)
      : 0.5 * bt * betacf(x, a, b);

  return result;
}

function beta(a, b) {
  return Math.exp(logGamma(a) + logGamma(b) - logGamma(a + b));
}

function logGamma(z) {
  const g = 7;
  const p = [
    0.99999999999980993,
    676.5203681218851,
    -1259.1392167224028,
    771.32342877765313,
    -176.61502916214059,
    12.507343278686905,
    -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7
  ];
  if (z < 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - logGamma(1 - z);
  z -= 1;
  let x = p[0];
  for (let i = 1; i < g + 2; i++) x += p[i] / (z + i);
  const t = z + g + 0.5;
  return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x);
}

function tTest(a, b, pooled = false) {
  const mean = arr => arr.reduce((x,y)=>x+y,0)/arr.length;
  const variance = arr => {
    const m = mean(arr);
    return arr.reduce((x,y)=>x+Math.pow(y-m,2),0)/(arr.length-1);
  };

  const m1 = mean(a), m2 = mean(b);
  const v1 = variance(a), v2 = variance(b);
  const n1 = a.length, n2 = b.length;

  let se, df;

  if (pooled) {
    const sp2 = ((n1-1)*v1 + (n2-1)*v2) / (n1 + n2 - 2);
    se = Math.sqrt(sp2 * (1/n1 + 1/n2));
    df = n1 + n2 - 2;
  } else {
    se = Math.sqrt(v1/n1 + v2/n2);
    df = Math.pow(v1/n1 + v2/n2,2) /
         (Math.pow(v1/n1,2)/(n1-1) + Math.pow(v2/n2,2)/(n2-1));
  }

  const t = (m2 - m1) / se;
  const p = 2 * (1 - tCDF(Math.abs(t), df));
  const crit = Math.abs(tInv(0.975, df)); // approx
  const ci = [
    (m2 - m1) - crit * se,
    (m2 - m1) + crit * se
  ];

  return { t, df, se, p, diff: m2 - m1, ci };
}

function renderTTestResults(groups, conds) {
  const container = document.getElementById("tTestResults");

  if (!document.getElementById("showTTest").checked) {
    container.style.display = "none";
    container.innerHTML = "";
    return;
  }

  const pooled = document.getElementById("usePooled").checked;
  const res = tTest(groups[conds[0]], groups[conds[1]], pooled);

  container.style.display = "block";
  container.innerHTML = `
    <strong>Two-Sample t-Test (${pooled ? "Pooled" : "Unpooled"})</strong><br><br>
    <table style="border-collapse:collapse;">
      <tr><td style="padding-right:12px;">Difference in means</td><td>${res.diff.toFixed(3)}</td></tr>
      <tr><td>Standard error</td><td>${res.se.toFixed(3)}</td></tr>
      <tr><td>t statistic</td><td>${res.t.toFixed(3)}</td></tr>
      <tr><td>Degrees of freedom</td><td>${res.df.toFixed(2)}</td></tr>
      <tr><td>p-value (two-sided)</td><td>${res.p.toFixed(4)}</td></tr>
      <tr>
        <td>95% CI for Δμ</td>
        <td>[${res.ci[0].toFixed(3)}, ${res.ci[1].toFixed(3)}]</td>
      </tr>
    </table>
  `;
}

function tInv(p, df, tol = 1e-8) {
  if (p <= 0 || p >= 1) {
    throw new Error("p must be between 0 and 1");
  }

  // exploit symmetry
  if (p < 0.5) {
    return -tInv(1 - p, df, tol);
  }

  let low = 0;
  let high = 10;

  // expand upper bound if needed
  while (tCDF(high, df) < p) {
    high *= 2;
  }

  while (high - low > tol) {
    const mid = (low + high) / 2;
    if (tCDF(mid, df) < p) {
      low = mid;
    } else {
      high = mid;
    }
  }

  return (low + high) / 2;
}
  
</script>

</body>
</html>
